/* Author: Nick Palutsis
	Date: March 4, 2016
	CSE 20212
	Lab 6 */
	
USER: The program works by first prompting the user for a file. This file then used as the Sudoku board to be solved. It is printed out to the user, and then a solution is printed out to the user after changing the zeros to valid numbers. If the program cannot correctly solve the puzzle, it will still print out the most complete version of the board possible for it. The program then ends.

INTERNAL: The main.cpp file creates a single Puzzle object of type int, and then uses a single call to the simulate function of this object. The constructor in puzzle.h asks the user for a file, and then it uses cin to read in the name of the file. Using ifstream it opens the file. Then a vector of size 9 is created, and a 2-dimenstional vector is created by using push_back() with the single vector. Then a 3-D vector is created by using push_back() with this 2-D vector. Then using two for loops the values from the file are assigned to the elements in the 3-D array to create the board. The simulate() function runs a while loop that loops as long as there are no more zeros left on the board showing that the board is not solved. Print() uses nested for loops to print out the elements of the first level of the 3-D vector to the user. FindOptions() uses nested for loops to check the first-level elements of the 3-D vector. If an element is zero then it uses another for loop to test every possibility for that element using checkAcross(), checkDown(), and checkBox(). If it is a valid move, then the value in the value in the 3-d space is assigned to 1, if it is not valid it is assigned to 0. onlyOne() then uses 2 for loops to cycle through each element of the board, and then if it is a 0 numOptions() checks to see if there is only a single valid move, and if so, it assigns that value to the spot on the board. Singleton() uses three separate functions which checks for singletons in the rows, columns, and mini grids by comparing the third dimension element across the row, column, or grid. If two elements both have a 1 assigned, then both values are changed to 0. onlyOne() then replaces the values of any new elements that now only have one possibility. Both onlyOne() and singleton() return ints so that they can be used in the if/else statement in simulate(); If no values are changed in onlyOne() then the program will test singleton(). If no changes are made in singleton() then the program breaks from the loop and the board is printed to the user. 

TEST: The program was tested by first ensuring that the program could read in a file containing a Sudoku puzzle and print it out. It was then tested to see if it could correctly solve the easy puzzle which it always does. It was then tested to see if it could complete the medium puzzle. When this was tested it continuously ran since it would never exit the while loop because it was unable to solve the problem. To fix this problem the algorithms were placed in if/else statements so that it would break from the loop if none of the algorithms made any changes. Now it will at least print out the puzzle solved to the best of its ability.

The functions findOptions() and onlyOne() worked well because findOptions() correctly found every option possible for an empty element and recorded these options in the 3-D vector. OnlyOne() then effectively was able to sort through the elements and change any elements that only one possible option. Singleton() was supposed to search through the elements afterwards and compare the elements that had multiple options. By comparing the possible options against other elements in the same row, column, or minigrid it would be able to rule out any values that could be used for more than one element, thus leaving only one possible option for some elements. onlyOne() could then be used again to change these values. While it appears that it worked for the majority of the medium puzzle since only a few elements are left unsolved, it still does not work perfectly since there is no possible value to replace the remaining zeros with without breaking the rules of the board.
