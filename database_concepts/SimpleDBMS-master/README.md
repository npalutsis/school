# SimpleDBMS

The code files that we have given you for HW4 can be grouped into several collections of related files. Some files appear in more than one collection. Below, we discuss each collection in turn.

### Files that define and implement the parser
*dbms_parser.py
*dbms_lexer.py
You do not need to understand the code in these files, and you will not be modifying them.

### Files related to WHERE-clause evaluation
*conditional_expression.py
*and_expression.py
*or_expression.py
*not_expression.py
*true_expression.py
*comparison.py
*compare_term.py
You will be implemeting the or_expression module, so you will need to understand some of the details of the code that the other files contain and get understand how the WHERE-clause evaluation is carried out.

In a parsed SQL command, a WHERE clause is essentially a tree data structure. For example, the WHERE clause

`        WHERE comm < 14 AND (office = 'Tokyo' OR office = 'Chicago')`
would form a tree that looks like this:
```
                          AND
                   ------/   \-----
                  /                \
                <                  OR
              /   \           ----/  \----
             comm 14         /            \
                           ==              ==
                          /  \            /  \
                      office "Tokyo"  office  "Chicago"
```
A WHERE clause is represented by a reference to the object that serves as the root of the WHERE-clause tree. This object is an instance of one of the subclasses of the abstract class ConditionalExpression. To evaluate the clause, we simply invoke the root object's isTrue() method, which returns true if the expression is true for the current values of the columns involved, and false otherwise. The leaf nodes of the tree are terms that are being compared. These terms are either columns or literal values. The CompareTerm class is used for literal values. The Column class is used for columns; it is a subclass of CompareTerm.

We have given you almost all of the code needed for evaluating WHERE clauses. The one exception is the code for the or_expression.

### Files for classes of objects generated by the parser
* sql_statement.py (and its subclasses; more on them later)
* table.py
* column.py
* column_options.py
* limit.py
The SQL parser takes the SQL command entered by the user (a string of characters) and breaks it up into a set of tokens. Each token represents one element of the command - a table name, a column name, a column value, etc.

In the SimpleDBMS, these tokens are represented by objects, and the tokens for a given command are managed by an object that represents the command as a whole. For example, if the user enters a SELECT command, the parser will generate an object of type SelectStatement, and we will use that object to access the objects that represent the individual tokens of that command (e.g., the names of the table or tables on which the SELECT command is operating).

The objects that represent the command as a whole are instances of one of the subclasses of the abstract class SQLStatement. These subclasses will be described in the next section. The classes used for the tokens include the classes mentioned above (Table, Column, ColumnOptions, Limit), the classes for conditional expressions mentioned in the previous table, and several built-in Java classes (String, Integer, Double). All SQLStatement subclasses have methods that allow you to get information about the tokens of a particular type (e.g., getTable(), getColumn(), numTables(), numColumns(), etc.). These accessor methods are defined in the SQLStatement class itself, and the subclasses inherit them.

### Files for classes of objects that represent SQL commands
* BeginStatement (for BEGIN TRANSACTION)
* CommitStatement (for COMMIT TRANSACTION)
* CreateStatement
* DeleteStatement
* DropStatement
* InsertStatement
* RollbackStatement (for ROLLBACK TRANSACTION)
* SelectStatement
* UpdateStatement
These classes are in their own pythong modules/files and contain the class definitions for the subclasses of the abstract class SQLStatement that was mentioned above. Each subclass represents one type of SQL command.

The SQLStatement superclass includes an abstract method called execute. Each subclass has its own version of that method, that performs the operations needed to carry out that command. We have given you the execute method for CREATE TABLE and DROP TABLE commands, and part of the execute method for INSERT commands. You will complete the INSERT version of execute.

### Files for classes of objects that are used to access and manipulate the contents of a relation
* table.py
* column.py
* insert_row.py
* relation_iterator.py
* table_iterator.py
The Table and Column classes are used for two different purposes. First, they are used to represent tokens generated by the parser, in which case they primarily serve as identifiers that specify the name of the table or column. Second, they are used to represent the storerepresentations of actual tables and columns in the relational database. If the parser generates an instance of one of these classes, it may be necessary to fill in some of the fields of the object before it can used to actually represent a stored table or column. You should not need to add or modify these two classes, but it is important that you understand the methods that they contain. You should at least read the comments that precede each method, and you may also want to look over the bodies of the methods to get some idea of how they work.

InsertRow objects are used to marshall the values in a row that is being inserted, turning them into a single key/data pair. The remaining classes define objects for iterating over some or all of the tuples in a relation. You will implement some of the the methods in these classes.

Read the text on [Marshalling](Marshalling.md) for more discussion.

### Files that implement the DBMS infrastructure
* simple_dbms.py
* catalog.py
* table.py

simple_dbms.py contains the main() method for the application. It also has methods/functions for initializing and shutting down the DBMS, including code for configuring and opening the Berkeley DB environment used for the underlying BDB databases.

catalog.py contains the code implementing the simple_dbms database schema (called the 'catalog'), which stores the per-table metadata associated with each table in the DBMS.

table.py includes support for an in-memory table cache, which keeps track of all tables whose underlying Berkeley DB databases have already been opened. When a table is opened, the corresponding Table object is stored in this cache for possible future use.

You should not need to modify these files, but it is important that you understand the methods that they contain. You should at least read the comments that precede each method, and you may also want to look over the bodies of the methods to get some idea of how they work.

Copyright Notice - Much of this project is based (with permission) on code written by David Sullivan at Harvard.